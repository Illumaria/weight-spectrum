# -*- coding: utf-8 -*-
"""weights_distribution_habr.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZnNEJxaFC9X5cy2NV5JeclWh_kKbpnvK
"""

from math import log2
from functools import reduce
from operator import xor
from multiprocessing import Process, Manager, cpu_count
from tqdm import tqdm
import time

# EQUAL
# Read file as a list of integers
def read(path):
    with open(path, "r") as fin:
        vectors = [x.rstrip() for x in fin.readlines()]
        vector_len = len(vectors[0])
        vector_num = len(vectors)
        vectors = list(map(lambda x: int(x, 2), vectors))
        return (vectors, vector_num, vector_len)

def get_zeros_pos(vec_sum, vector_len):
    zeros_pos = []
    vec_sum_str = bin(vec_sum)[2:]
    vec_sum_len = len(vec_sum_str)
    zeros_pos = [i for i, j in enumerate(vec_sum_str[::-1]) if j == '0']
    new_vector_len = vec_sum_len - len(zeros_pos)
    return (zeros_pos, new_vector_len)

def delete(vector, zeros_pos):
    bin_vector = bin(vector)[2:]
    for zero_pos in zeros_pos[::-1]:
        if zero_pos < len(bin_vector):
            bin_vector = bin_vector[:len(bin_vector)-zero_pos-1] + bin_vector[len(bin_vector)-zero_pos:]
    vector = int(bin_vector, 2)
    return vector

def delete_zeros(vectors, vector_len):
    vec_sum = 0
    for vec in vectors:
        vec_sum |= vec
    zeros_pos, new_vector_len = get_zeros_pos(vec_sum, vector_len)
    vectors = list(map(lambda x: delete(x, zeros_pos), vectors))
    return (vectors, new_vector_len)

def getoptbasis(vectors, vector_num, vector_len):
    # Initial rank equals to the full rank
    rank = min(vector_len, vector_num)

    for r in range(rank):
        vectors = sorted(vectors, reverse=True)
        index = len(bin(vectors[r])[2:]) - 1
        for i in range(vector_num):
            if (vectors[i] & 1 << index) and (i != r):
                vectors[i] ^= vectors[r]

    basis = [vectors[i] for i in range(rank) if vectors[i]]
    rank = len(basis)
    return (basis, rank)

def partition(start, end, cores):
    dn = round((end - start + 1) / cores)
    parts = []
    parts += [[start, start + dn - 1]]
    parts += [[dn * (i - 1), i * dn - 1] for i in range(2, cores)]
    parts += [[(cores - 1) * dn, end]]
    return parts

def count_ones(int_num):
    # The code provided below does not invoke
    # any type convertions and only performs
    # as many cycles as there are '1' digits
    # in a binary representation of a number

    # count = 0
    # while(int_num != 0):
    #     int_num &= int_num - 1
    #     count += 1
    # return count

    # However, this solution turns out to be faster
    return bin(int_num).count('1')

def gray_code(index):
    return index ^ (index // 2)

def get_spectrum(basis, vector_len, bounds, total_spectrum, pbar=None):
    spectrum = [0] * (vector_len + 1)

    # Calculate first vector in the given range and its weight
    current_vector = 0
    if bounds[0] != 0:
        i = 0
        gray_encode = gray_code(bounds[0])
        while gray_encode:
            if gray_encode % 2 == 1:
                current_vector ^= basis[i]
            i += 1
            gray_encode //= 2

    spectrum[count_ones(current_vector)] += 1

    for i in range(bounds[0], bounds[1]):
        bit_change_pos = int(log2((-1-i) & (1+i)))
        current_vector ^= basis[bit_change_pos]
        weight = count_ones(current_vector)
        spectrum[weight] += 1
        if pbar:
            pbar.update()
    if pbar:
        pbar.close()

    total_spectrum.append(spectrum)

def process(basis, rank, vector_len_wz, vector_len, vector_num, cores):
    spectrum = []
    if rank == vector_len_wz:
        spectrum = [1]
        for i in range(1, rank+1):
            spectrum.append(int(spectrum[i-1] * (rank-i+1) / i))
    else:
        parts = partition(0, 2**len(basis) - 1, cores)
        with Manager() as manager:
            pbar = tqdm(total=parts[0][1])
            total_spectrum = manager.list()
            processes = []
            processes.append(Process(target=get_spectrum, args=(basis, vector_len, parts[0], total_spectrum, pbar)))
            processes[1:] = [Process(target=get_spectrum, args=(basis, vector_len, part, total_spectrum)) for part in parts[1:]]
            for p in processes:
                p.start()
            for p in processes:
                p.join()
            spectrum = [sum(x) for x in zip(*total_spectrum)]
    spectrum = [int(weight * 2**(vector_num - rank)) for weight in spectrum]
    return spectrum

def write(spectrum, path):
    with open(path, "w") as fout:
        for i, elem in enumerate(spectrum[:-1]):
            fout.write("{}\t{}\n".format(i, elem))
        else:
            fout.write("{}\t{}".format(i+1, spectrum[-1]))

def main(input_file, output_file, cores):
    basis, vector_num, vector_len = read(input_file)
    start_time = time.time()
    basis, vector_len_wz = delete_zeros(basis, vector_len)
    basis, rank = getoptbasis(basis, vector_num, vector_len_wz)
    spectrum = process(basis, rank, vector_len_wz, vector_len, vector_num, cores)
    print("\n--- %s seconds ---" % (time.time() - start_time))
    print("\nWriting output to {}...".format(output_file))
    write(spectrum, output_file)
    print("Done.")

if __name__ == "__main__":
    main("/content/in_33_64.txt", "/content/output.txt", cpu_count())

# in_24_32.txt: 1 loop, best of 3: 20.2 s per loop (-18.5% vs Git/Habr)
# in_31_32.txt: 1233.2595570087433 seconds         (-15.7% vs Git/Habr)